"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dictionary_literal = dictionary_literal;
const set_1 = require("./set");
const not_set_1 = require("./not_set");
const array_literal_1 = require("./array_literal");
/**
 * this is an implementation, not public by design
 */
class Dictionary {
    constructor(source) {
        this.source = source;
    }
    map($v) {
        return new Dictionary(this.source.map(($) => {
            return {
                key: $.key,
                value: $v($.value, $.key)
            };
        }));
    }
    __map_with_key($v) {
        return new Dictionary(this.source.map(($) => {
            return {
                key: $.key,
                value: $v($.value, $.key),
            };
        }));
    }
    to_array(compare) {
        const sorted_keys = this.source.slice().sort(compare);
        return (0, array_literal_1.array_literal)(sorted_keys);
    }
    __get_entry(key) {
        for (let i = 0; i !== this.source.length; i += 1) {
            const element = this.source[i];
            if (element.key === key) {
                return (0, set_1.set)(element.value);
            }
        }
        return (0, not_set_1.not_set)();
    }
    __add_entry_if_not_exists(key, value) {
        for (let i = 0; i !== this.source.length; i += 1) {
            const element = this.source[i];
            if (element.key === key) {
                return this;
            }
        }
        return new Dictionary([...this.source, { key: key, value: value }]);
    }
    __add_entry_overwrite_if_exists(key, value) {
        return new Dictionary(this.source.map((entry) => {
            if (entry.key === key) {
                return { key: key, value: value };
            }
            else {
                return entry;
            }
        }));
    }
    __remove_entry_if_exists(key) {
        return new Dictionary(this.source.filter((entry) => {
            return entry.key !== key;
        }));
    }
}
/**
 * returns a Exupery dictionary
 *
 * why is this not the constructor? to call a constructor, you have to use the keyword 'new'. Exupery doesn't use the concept of a class so that keyword should be avoided
 * @param source An object literal
 * @returns
 */
function dictionary_literal(source) {
    //first we clone the source data so that changes to that source will have no impact on this implementation.
    //only works if the set does not become extremely large
    function create_dictionary_as_array(source) {
        const imp = [];
        Object.keys(source).forEach((key) => {
            imp.push({ key: key, value: source[key] });
        });
        return imp;
    }
    const daa = create_dictionary_as_array(source);
    return new Dictionary(daa);
}
